{"body":"# dibble\r\n\r\nDibble is a Clojure library that intelligently, randomly seeds databases by inferencing the underlying table structure.\r\n\r\n## Installation\r\n\r\nAvailable on Clojars:\r\n\r\n    [dibble \"0.1.0-SNAPSHOT\"]\r\n\r\n## Usage\r\n\r\nA few complete examples follow. Starting with the simplest case, suppose we have a MySQL table named `people`:\r\n```sql\r\nmysql> desc people;\r\n+--------+---------------+------+-----+---------+-------+\r\n| Field  | Type          | Null | Key | Default | Extra |\r\n+--------+---------------+------+-----+---------+-------+\r\n| name   | varchar(32)   | YES  |     | NULL    |       |\r\n| number | int(11)       | YES  |     | NULL    |       |\r\n+--------+---------------+------+-----+---------+-------+\r\n```\r\n\r\nLet's seed that table:\r\n```clojure\r\n(ns my.seeder\r\n  (:require [dibble.core :refer :all]))\r\n\r\n;;; A map that specifies the database type via :vendor and Korma connection information.\r\n(def db {:vendor :mysql :db \"simulation\" :user \"root\" :password \"\"})\r\n\r\n;;; Makes 50 different seeds, deleting all rows in the table before beginning (using :clean-slate).\r\n(defseed people\r\n  {:database db :table :people :policy :clean-slate :n 50}\r\n  (randomized :name)    ;;; random 32-char string\r\n  (randomized :number)) ;;; random 32-bit integer\r\n\r\n(seed-table people)\r\n```\r\n\r\nValues don't have to be totally random. Dibble offers some constraints:\r\n```clojure\r\n(ns my.seeder\r\n  (:require [dibble.core :refer :all]))\r\n\r\n(def db {:vendor :mysql :db \"simulation\" :user \"root\" :password \"\"})\r\n\r\n(defseed people\r\n  {:database db :table :people :policy :clean-slate :n 50}\r\n  (randomized :name {:length 16})        ;;; random 16-char string\r\n  (randomized :number {:min 5 :max 10})) ;;; random integer between 5 and 10 inclusive\r\n\r\n(seed-table people)\r\n```\r\n\r\nDibble handles tables that have foreign keys. Let's introduce another table to up the complexity a smidge:\r\n```sql\r\nmysql> desc pets;\r\n+-------+-------------+------+-----+---------+-------+\r\n| Field | Type        | Null | Key | Default | Extra |\r\n+-------+-------------+------+-----+---------+-------+\r\n| pid   | int(11)     | YES  |     | NULL    |       |\r\n| name  | varchar(32) | YES  |     | NULL    |       |\r\n+-------+-------------+------+-----+---------+-------+\r\n```\r\n\r\nSuppose the `number` column in the `people` table refers to the `pid` column of `pets`, effectively making `pid` a foreign key. Each time we generate a seed for a row in the `people` table, we want to generate a row in the `pets` table so the data makes semantic sense. Here's the code to do that:\r\n\r\n```clojure\r\n(ns dibble.seeder\r\n  (:require [dibble.core :refer :all]))\r\n\r\n(def db {:vendor :mysql :db \"simulation\" :user \"root\" :password \"\"})\r\n\r\n(defseed pets\r\n  {:database db :table :pets} ;;; don't specify a policy since it depends on other tables\r\n  (inherit :pid)              ;;; :pid is given to us from another row in another table\r\n  (randomized :name))\r\n\r\n;;; Policy :transitive specifies deleting all rows in all tables of the :dependents sequence\r\n;;; before seeding.\r\n(defseed people\r\n  {:database db :table :people :policy :transitive :dependents [:pets] :n 50}\r\n  (randomized :name)\r\n  (randomized :number {:fk [pets :pid]})) ;;; :fk specifies a vector of a table and column to place :number into\r\n\r\n(seed-table people)\r\n```\r\n\r\n## License\r\n\r\nCopyright Â© 2012 Michael Drogalis\r\n\r\nDistributed under the Eclipse Public License, the same as Clojure.\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"A Clojure library for seeding databases.","google":"","name":"Dibble"}